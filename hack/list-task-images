#!/bin/bash  
# A Script to create a table of images and their user across tasks
# and the task and owners from the OWNERS file
# Updates a file called owners.md with a markdown table. 
 
SCRIPTDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )" 
TASKSDIR=${SCRIPTDIR}/../pac/tasks
IMAGES_TO_TASKS=$(mktemp -d)   
FULL_IMAGE_REFS=$(mktemp)
# These are the name of params which may have default images
# so the script checks them for default values
PARAM_WITHIMAGES="BUILDER_IMAGE GIT_IMAGE SCRIPT_IMAGE IMAGE"
function showTask() { 
    TASK_NAME=$(yq .metadata.name $1)
    echo "Processing $TASK_NAME" 
    IMAGE_REFS=$(mktemp)
    FULL_IMAGE=$(yq .spec.steps[].image $1)
    echo "$FULL_IMAGE" | grep -v "\$(" | cut -d '@' -f 1  > $IMAGE_REFS 
    echo "$FULL_IMAGE"  >> $FULL_IMAGE_REFS 

    for tag in $PARAM_WITHIMAGES; do  
        IMAGE=$(yq '.spec.params.[] | select(.name == "'$tag'").default' $1)  
        if [ "$IMAGE" != "" ] && [ "$IMAGE" != "null" ]; then
            NO_SHA=$(echo $IMAGE | cut -d '@' -f 1 ) 
            echo "$NO_SHA"  >> $IMAGE_REFS
            echo "$IMAGE"  >> $FULL_IMAGE_REFS
            cat $FULL_IMAGE_REFS 
        fi 
    done
    while read p; do  
      file=$(echo $p | sed "s!/!__!g")
      touch $IMAGES_TO_TASKS/$file
      echo $TASK_NAME >>$IMAGES_TO_TASKS/$file   
    done < $IMAGE_REFS     
} 
 
# Compute the list of images and which tasks they are in 
for task in $(ls $TASKSDIR); do 
  showTask $TASKSDIR/$task   
done  

OUTPUT_SHARED_IMAGE=$(mktemp)
# Compute the list of images and which tasks use them
echo "## Images shared across Tasks"  >$OUTPUT_SHARED_IMAGE
printf "|  Num   |  Image   | Task(s)  | Count   | \n" >>$OUTPUT_SHARED_IMAGE
printf "| -------- | -------- | -------  | ------- | \n" >>$OUTPUT_SHARED_IMAGE 
count=0
for sorted_filename in `ls $IMAGES_TO_TASKS | sort -g` ; do 
  let count++ 
  imagename=$(echo $sorted_filename | sed "s!__!/!g") 
  tasks=$(cat $IMAGES_TO_TASKS/$sorted_filename | uniq | sort) 
  number=$(cat $IMAGES_TO_TASKS/$sorted_filename | uniq | wc -l)
  tasks=${tasks//$'\n'/, }  
  FORMAT="| "$count" | "$imagename" | "$tasks" | "$number" | \n" 
  printf "$FORMAT"  >>$OUTPUT_SHARED_IMAGE
done 

OUTPUT=${SCRIPTDIR}/../images-info.md 
echo "# TSSC Sample Pipelines " >$OUTPUT
cat $OUTPUT_SHARED_IMAGE >>$OUTPUT

# Table of Images by Registry
SORTED_FULL=$(mktemp)
cat $FULL_IMAGE_REFS | sort | uniq > $SORTED_FULL
echo 
echo "# By Registry" >>$OUTPUT
REGISTRY=""
while read p; do  
    NEW_REG=$(echo $p | cut -d "/" -f1)
    if [ "$NEW_REG" != "$REGISTRY" ]; then
        echo >>$OUTPUT 
        printf "## Registry: $NEW_REG\n" >>$OUTPUT
        printf "| Org | Image | Tag | \n" >>$OUTPUT
        printf "| ------- | ------- | ------- |\n" >>$OUTPUT
        REGISTRY=$NEW_REG
    fi 
    ORG=$(printf "$p" | cut -d "/" -f2 | cut -d "@" -f1 | tr -d $'\n')
    IMG=$(printf "$p" | cut -d "/" -f3 | cut -d "@" -f1 | tr -d $'\n')
    TAG=$(printf "$IMG" | cut -d ":" -f2 | cut -d "@" -f1 | tr -d $'\n')
    IMG=$(printf "$IMG" | cut -d ":" -f1 | cut -d "@" -f1 | tr -d $'\n')
 
    printf "| $ORG | $IMG | $TAG |\n" >>$OUTPUT
done < $SORTED_FULL
 
# Full Image URIs
echo "## Images Full URI " >>$OUTPUT
printf "| Num | Image |\n" >>$OUTPUT
printf "| ------- | ------- |\n" >>$OUTPUT
cat $FULL_IMAGE_REFS | sed 's/^/| /' | sort | uniq  | cat -n | sed 's/^/| /'  >>$OUTPUT
 